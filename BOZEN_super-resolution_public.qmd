---
title: "BOZEN_super-resolution"
author: "Albin Bjärhall"
format: html
---

## Super-resolution sub-task: Quantitative performance evaluation

This script tries to recreate the evaluation of super-resolution images described in this article \["https://medium.com/@ya_71389/sentinel-2-deep-resolution-3-0-c71a601a2253ndefined"\] as part of the activities in the Habitat pilot.

The evaluation includes scatter-plotting the pixel values of a super-resolution image against a reference image (with the same pixel resolution) and calculate the following metrics: R2, RMSE, PSNR and SSIM. The script also includes options to re-calibrate the super-resolution map by histogram-matching, visualize the maps in RGB and plot the pixel-value histograms.

```{r deps, results='hide', message=FALSE, warning=FALSE}
library(terra)
library(ggplot2)
library(dplyr)
library(sf)
library(viridis)
library(SSIMmap)
```

## Load data

Upload a file of the AOI and the map images that you would like to evaluate (by changing the directories in the code below). The script is currently set up for comparing a deep-resolution image from S2DR3 with a Sentinel-2 scene. For evaluating a super-resolution image from Satlas (with modelled RGB bands, and pan-sharpened B08, B11 and B12), un-comment the last sections of the code below.

```{r setup, results='hide'}
# upload AOI as geojson, shapefile or geopackage
aoi <- st_read("C:/.../aoi.geojson")
# upload S2 scene
s2 <- rast("C:/.../BOZEN_super-resolution/S2DR3-Bozen/2024-08-10/S2L2A_T32TPS-b4b497962-20240810_MS.tif")
if (crs(s2) != crs(aoi)) {
  s2 <- project(s2, crs(aoi))
}
# upload S2DR3T image from same date as the S2 scene
s2dr3 <- rast("C:/.../BOZEN_super-resolution/S2DR3-Bozen/2024-08-10/S2L2Ax10_T32TPS-b4b497962-20240810_MS.tif")
if (crs(s2dr3) != crs(aoi)) {
  s2dr3 <- project(s2dr3, crs(aoi))
}
stopifnot(
  crs(s2) == crs(aoi),
  crs(s2dr3) == crs(aoi)
)
# crop images to the aoi
s2dr3 <- crop(s2dr3, vect(aoi))
s2 <- crop(s2, vect(aoi))

#########################
## Un-comment the section below if you want to evaluate a Satlas image
#########################
# # The Satlas images were provided as one file containing the RGB bands (scaled from 0-255) and bands 8, 11, 12 provided as separate files (scaled 0-10000).
# # Start by re-scaling the RGB bands, then combine all bands to one file.
# satlas_rgb <- rast("C:/.../Satlas_BOZEN/24_July_August/sr_mosaic.tif")
# satlas_scaled <- satlas_rgb * (10000 / 255)
# names(satlas_scaled) <- c("B04", "B03", "B02")
# # Add pan-sharpened bands
# satlas_b8  <- rast("C:/.../Satlas_BOZEN/24_July_August/ps_b_8_wave.tif"); names(satlas_b8)  <- "B08"
# satlas_b11 <- rast("C:/.../Satlas_BOZEN/24_July_August/ps_b_12_wave.tif"); names(satlas_b11) <- "B11"
# satlas_b12 <- rast("C:/.../Satlas_BOZEN/24_July_August/ps_b_13_wave.tif"); names(satlas_b12) <- "B12"
# satlas <- c(satlas_scaled[["B02"]], satlas_scaled[["B03"]], satlas_scaled[["B04"]], satlas_b8, satlas_b11, satlas_b12)
# if (crs(satlas) != crs(aoi)) {
#   satlas <- project(metria, crs(aoi))
# }
# stopifnot(
#   crs(satlas) == crs(aoi)
# )
# metria <- crop(satlas, vect(aoi))
```

## Crop bands and downscale SR map

Specify which super-resolution map you are evaluating (currently set to S2DR3) and which reference map you want to compare it to (currently set to Sentinel-2). For the evaluation, the two maps should have the same resolution and contain the same bands. Depending on how many bands your super-resolution and reference map have (the S2DR3-images and S2-scenes both contain the same 10 bands, whereas the Satlas images contains 6 bands), you may have to crop out the bands of the SR_map from the ref_map (or vice versa) by un-commenting the corresponding line in the code below. Also note that if you are using an orthophoto (instead of an S2 scene) as ref_map, then the ref_map should be down-scaled to match the resolution of the SR_map (instead of down-scaling the SR_map to match the ref_map as the script currently does).

```{r filter}
## Specify which two images (SR_map & ref_map) you want to evaluate
# SR_map <- s2dr3
SR_map <- satlas
ref_map <- s2
## Downscale the image with the higher resolution to match the resolution of the other. If your ref_map has the higher resolution, un-comment the row below and switch places of 'SR_map' and 'ref_map' in the line for resampling (down-scaling the resolution) of the SR_map/ref_map. 
SR_original <- SR_map
# ref_original <- ref_map
SR_map <- resample(SR_map, ref_map, method = "bilinear")
## Make sure the two maps contain the same bands. Check which bands your two maps have by un-commenting the two lines below
# names(SR_map)
# names(ref_map)
## If necessary, crop out the common bands from whichever file has the more bands by un-commenting one of the two lines below. The first line will extract the bands existing in SR_map from the ref_map (use this for evaluating the Satlas image), and the second line does to opposite.
ref_map <- ref_map[[names(SR_map)]]
# SR_map <- SR_map[[names(ref_map)]]
stopifnot(
  names(SR_map) == names(ref_map),
  all(res(SR_map) == res(ref_map))
)
bands <- names(ref_map)
```

## Optional: Histogram matching

Un-comment and run the section below if you want to match the histogram of the SR_map with that of the ref_map

```{r histogram-match}
hist_match <- function(target_spat, ref_spat) {
  matched_spat <- target_spat
  for (i in 1:nlyr(target_spat)) {
    target_vals <- values(target_spat[[i]], mat = FALSE)
    ref_vals <- values(ref_spat[[i]], mat = FALSE)
    target_vals <- target_vals[!is.na(target_vals)]
    ref_vals <- ref_vals[!is.na(ref_vals)]
    target_ecdf <- ecdf(target_vals)
    ref_quant <- quantile(ref_vals, probs = seq(0, 1, length.out = 1000), na.rm = TRUE)
    map_vals <- function(x) {
      p <- target_ecdf(x)
      approx(seq(0, 1, length.out = 1000), ref_quant, xout = p, rule = 2)$y
    }
    matched_vals <- map_vals(values(target_spat[[i]], mat = FALSE))
    out_layer <- target_spat[[i]]
    values(out_layer) <- matched_vals
    matched_spat[[i]] <- out_layer
  }
  return(matched_spat)
}

SR_match <- hist_match(SR_map, ref_map)
```

## Optional: Visual comparison of the maps over orthophoto

Un-comment and run the section below if you want to visually compare the different maps over a WMS. Change the "baseUrl" and "layers" to match your local orthophoto.

```{r visualize}
# library(leafem)
# library(leaflet)
# ref_RGB <- clamp(ref_map[[c("B02", "B03", "B04")]] * 255 / 10000, lower = 0, upper = 255)
# SR_RGB <- clamp(SR_map[[c("B02", "B03", "B04")]] * 255 / 10000, lower = 0, upper = 255)
# SR_original_RGB <- clamp(SR_original[[c("B02", "B03", "B04")]] * 255 / 10000, lower = 0, upper = 255)
# # SR_match_RGB <- clamp(SR_match[[c("B02", "B03", "B04")]] * 255 / 10000, lower = 0, upper = 255)
# 
# leaflet() %>%
#   addWMSTiles(
#     baseUrl = "http://url/to/local/orthophoto/wms",
#     layers = "layer-name-of-wms",
#     options = WMSTileOptions(
#       format = "image/jpeg",
#       transparent = FALSE
#     ),
#     group = "Orthophoto"
#   ) %>%
#   addRasterRGB(ref_RGB[[1:3]], r = 3, g = 2, b = 1, group = "Reference map") %>%
#   addRasterRGB(SR_RGB[[1:3]], r = 3, g = 2, b = 1, group = "Super-resolution (downscaled) map") %>%
#   addRasterRGB(SR_original_RGB[[1:3]], r = 3, g = 2, b = 1, group = "Super-resolution (original) map") %>%
#   # addRasterRGB(SR_match_RGB[[1:3]], r = 3, g = 2, b = 1, group = "Super-resolution (histogram-matched) map") %>%
#   addLayersControl(
#     baseGroups = c("Orthophoto"),
#     overlayGroups = c(
#       "Reference map", 
#       "Super-resolution (downscaled) map", 
#       # "Super-resolution (histogram-matched) map",
#       "Super-resolution (original) map"
#       ),
#     options = layersControlOptions(collapsed = FALSE)
#   )
```

## Optional: Plot histograms of RGB bands

Un-comment and run the section below if you want to plot and compare the histograms of the RGB bands of the maps

```{r histogram}
# plot_histograms <- function(raster_obj, title_prefix = "Raster") {
#   par(mfrow = c(1, nlyr(raster_obj)))  # 1 row, N columns
#   for (i in 1:nlyr(raster_obj)) {
#     hist(values(raster_obj[[i]]), 
#          breaks = 100, 
#          main = paste(title_prefix, "- B", i),
#          xlab = "Pixel Values", 
#          col = "gray", 
#          border = "black")
#   }
#   par(mfrow = c(1,1))  # Reset layout
# }
# 
# plot_histograms(ref_RGB, "Ref")
# plot_histograms(SR_RGB, "SR-downsc.")
# plot_histograms(SR_original_RGB, "SR-orig.")
# # plot_histograms(SR_match_RGB, "SR-match")
```

## Create stack, calculate metrics and plot data

If you want to evaluate the histogram-matched version of the SR_map, simply assign SR_match (instead of SR_match) to SR_plot by un-commenting the line below.

```{r stack}
# SR_plot <- SR_map
SR_plot <- SR_match
ref_plot <- ref_map
## Stack the super-resolution and ref maps
stack_names <- c(
  paste0("SR_", bands),
  paste0("ref_", bands)
)
stack <- c(SR_plot, ref_plot)
names(stack) <- stack_names
# Convert stacks to data frames for pixel comparison
df <- as.data.frame(stack, xy = TRUE, na.rm = TRUE)
# Prepare the super-resolution and sentinel-2 images for plotting
plot_data <- data.frame()
for (band in bands) {
  SR_band <- paste0("SR_", band)
  ref_band <- paste0("ref_", band)
  if (!all(c(SR_band, ref_band) %in% colnames(df))) next
  # Combine pixel values into a long-format dataframe
  plot_data <- bind_rows(
    plot_data,
    data.frame(
      SR = df[[SR_band]],
      ref = df[[ref_band]],
      Band = paste0(band)
    )
  )
}
```

```{r metrics}
if (global(is.na(SR_plot), "sum", na.rm = TRUE)[1,1] > 0 ||
    global(is.na(ref_plot), "sum", na.rm = TRUE)[1,1] > 0) {
  stop("Filter out NA values before proceeding")
}

rmse_vals <- c()
r2_vals   <- c()
psnr_vals <- c()
ssim_vals <- c()

max_pixel <- 10000  # Maximum reflectance value for Sentinel-2 images

for (band in bands) {
  SR_vals  <- values(SR_plot[[band]], na.rm = TRUE)
  ref_vals <- values(ref_plot[[band]], na.rm = TRUE)

  # RMSE
  rmse <- sqrt(mean((SR_vals - ref_vals)^2))
  rmse_vals <- c(rmse_vals, rmse)

  # R²
  r2 <- 1 - sum((SR_vals - ref_vals)^2) / sum((ref_vals - mean(ref_vals))^2)
  r2_vals <- c(r2_vals, r2)

  # PSNR
  psnr <- 20 * log10(max_pixel / rmse)
  psnr_vals <- c(psnr_vals, psnr)

  # SSIM
  ssim_out  <- capture.output(ssim_raster(SR_plot[[band]], ref_plot[[band]]))
  ssim_line <- grep("SSIM:", ssim_out, value = TRUE)[1]
  ssim_val  <- as.numeric(sub(".*SSIM: ([0-9.]+).*", "\\1", ssim_line))
  ssim_vals <- c(ssim_vals, ssim_val)
}

rmse_avg <- mean(rmse_vals)
r2_avg   <- mean(r2_vals)
psnr_avg <- mean(psnr_vals)
ssim_avg <- mean(ssim_vals)

# Annotation text
metrics_text <- paste(
  paste0("RMSE = ", round(rmse_avg, 2)),
  paste0("R² = ", round(r2_avg, 3)),
  paste0("PSNR = ", round(psnr_avg, 2), " dB"),
  paste0("SSIM = ", round(ssim_avg, 3)),
  sep = "\n"
)
```

```{r plot}
# Scatterplot the values and add the metrics
ggplot(plot_data, aes(x = ref, y = SR, color = Band)) +
  geom_point(alpha = 0.3, size = 0.8) +
  guides(color = guide_legend(override.aes = list(size = 3))) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  theme_minimal() +
  scale_color_viridis_d(option = "B") +
  labs(
    title = "Super-resolution vs reference map",
    x = "Reference map",
    y = "Super-resolution map",
    color = "Band"
  ) +
  coord_fixed() +
  annotate("text", x = Inf, y = -Inf, hjust = 1.1, vjust = -0.5,
           label = metrics_text, size = 4, color = "black")
```
